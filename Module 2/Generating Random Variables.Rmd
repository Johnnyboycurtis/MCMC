---
title: "Generating Random Variables"
author: "Jonathan Navarrete"
date: "April 15, 2017"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

One of the fundamental tools required in monte carlo methods is the ability to generate pseudo-random variables from a specified probability distribution. We explore some of these methods starting with the Inverse Transform Method. One of the most fundamental number generation is the uniform random generation. Pseudo random number genrators rely on the assumption that computational methods can consistently generate uniform random numbers. Though, these notes do not dive deep into the mechanics of random number generation, they do provide an overview of some topics. After having the ability to generate simple random numbers transformations are used to simulate other random processes.



## Generation uniform samples


```{r}

u = runif(2000)

#par(mfrow=c(1,2))
hist(u, probability=TRUE)
lines(density(u), xlim=c(0,1))
#par(mfrow=c(1,1))

## Q-Q plot for `runif` data against true theoretical distribution:
qqplot(qunif(ppoints(500)), u,
      main = expression("Q-Q plot for" ~~ {Unif(0,1)}))
qqline(u, distribution = qunif,
      prob = c(0.1, 0.6), col = 2)


qqplot(u,1-u)
qqline(u, distribution = qunif)

hist(1-u, probability = TRUE) ## also follows a uniform dist
lines(density(1-u), xlim=c(0,1))

acf(u) ## autocorrelation of random number generation

```



## Generating Random Variables

In this section we'll cover the following methods for generating random numbers from a target distribution.

1. Inverse Transform Method

2. Accept-Reject Method

3. Transformation Method

4. Sums and Mixture distributions

5. Stochastic Processes




## Inverse Transform Method

General idea: only using a uniform distribution, generate random values and use an inverse CDF of the target distribution for which you wish to simulate. See the following link for further discussion: [How does the inverse transform method work?][1]

## Theorem (Probability Integral Transformation): 
If X is a continuous random variable with CDF $F_X(X)$, then $U = F_X(X) \sim Uniform(0,1)$. If $U \sim Uniform(0,1)$, then for all $x \in \mathbb R$

$$
P(F_X^{-1}(U) \leq x) = P(\inf\{t: F_X(t) = U\} \leq x)\\
\\= P(U \leq F_X(x))\\
\\=F_U(F_X(x)) = F_X(x)
$$
and therefore $F_X^{-1}(U)$ has the same distribution as $X$.



Steps:
1. For target probability distribution function (pdf) f(x), calculate the inverse of the CDF by setting F(x) = U, then solving for X, for which $U \sim Unif(0,1)$.

2. Generate N random numbers from $U \sim Unif(0,1)$

3. Plug in $u$ observed values in $F^{-1}(U)$ to obtain N $x$ values for which $X \sim f(x)$


### Example

Suppose we are interested in generating 10,000 random values from an Exponential distribution 

1. $f(X) = \lambda e^{- \lambda X}$

2. $F(X) = 1 - e^{- \lambda X} = U$

3. $F^{-1}(U) = - 1/\lambda \ log(1 - U)$; can use (1-u) or u, since both are uniformly distributed.

If we set $\lambda = 5$, then

```{r cars}
N = 10^4
u = runif(N)

fInv = function(u){
  (-1/5) * log(u) ## or log(1-u)
}

outSamples = fInv(u)


hist(outSamples, probability = TRUE)
lines(x = ppoints(200), y = dexp(x = ppoints(200), rate = 5), 
      col = "blue")
hist(rexp(n = N, rate = 5), probability = TRUE)
lines(x = ppoints(200), y = dexp(x = ppoints(200), rate = 5), 
      col = "blue")



qqplot(qunif(ppoints(500)), outSamples,
      main = expression("Q-Q plot for" ~~ {Exp(5)}))
qqline(outSamples, distribution = qexp,
      prob = c(0.1, 0.9), col = 2)



```


## Inverse Transform Discrete scenario
For a given an ordered discrete random sample $... < x_{i-1} < x_{i} < x_{i+1} < ...$ from a distribution $f(X)$, with CDF $F(x)$. Then, the inverse transformation $F_X^{-1}(u) = x_i$, where $F_X(x_{i-1}) < u \leq F_X(x_i)$. Then for each random variable desired,

1. Generate a random variable $u \sim Unif(0,1)$

2. Deliver $x_i$ where $F(x_{i-1}) < u \leq F(x_{i})$


## Example 

Given the following distribution $P(X = 0) = 0.1$, $P(X = 1) = 0.2$, $P(X = 2) = 0.2$, $P(X = 3) = 0.2$, and $P(X = 4) = 0.3$, use the inverse transform method to generate a random sample of size 1000 from the distribution.

$$
F(X \leq x) = 
\begin{cases}
    0.1       & \quad  \text{if } x \leq 0 \\
    0.3       & \quad  \text{if } x \leq 1\\
    0.5       & \quad  \text{if } x \leq 2\\
    0.7       & \quad  \text{if } x \leq 3\\
    1.0       & \quad  \text{if } x \leq 4\\
  \end{cases}
$$



```{r}
cdf = c(0.0, 0.1, 0.3, 0.5, 0.7, 1.0)
results = numeric(length = 1000) ## creates a vector of zeros
u = runif(1000)
for(i in 2:6){
    ind = (cdf[i-1] < u) & (u <= cdf[i])
    results[ind] <- (i-2)
}

table(results) / 1000


hist(results, probability = TRUE)

```



## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
#plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.




[1]: https://stats.stackexchange.com/questions/184325/how-does-the-inverse-transform-method-work
